
### 1.1 디자인패턴이 무엇인가
- One thing expert designers know not to do is solve every problem first principles. rather, they reuse solutions that have worked for then in the past.
    - 복잡하고 큰 문제의 경우에는 그럴 수 있을 것 같음.
    - 그렇지만 고수들도 첫 방식으로는 빠르게 문제를 해결할 수 있는 방법을 택하지 않을까?
    - 그리고 과거 적용했던 방식들을 참고하여, 그 방향으로 조금씩 리팩터링 해볼 것 같음

##### 이 책의 목적
- to record experience in designing object-oriented software as design patterns.
    - Object Oriented 가 언급된 것을 보아, 이 책에서 내오는 예제들은 객체지향이 아닌 다른 패러다임의 언어에서는 적용할 수 없는 패턴일까? 생각이 든다.
        - 번역본에 Object Oriented 를 생략한 것을 보고 경악했다.

##### 디자인패턴을 쓰면 좋은 점
- 좋은 설계나 아키텍처를 재사용하기가 수월함.
- 클래스와 객체간의 상호작용과 근본적인 의도를 명시함 -> 문서화와 유지보수에 도움을 줌

##### 디자인패턴의 4가지 요소
- 이름 pattern name
    - 설계 어휘를 늘려줌 (design vocabulary)
    - 디자인에 대해서 연상하기 쉬워지고, 원활한 커뮤니케이션을 도와줌
- 문제 problem
    - 해결할 문제와 배경
- 해결방법 solution
    - 구성하는 요소, 관계 책임, 협력관계
- 결과 consequences
    - 디자인패턴 적용 이후 결과와 trade-off

> Design patterns in this book are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.
> 이 책에서 다루는 디자인 패턴은 특정 상황에서 일반적인 설계 문제를 해결하기 위해 맞춤화된 객체와 클래스 간의 상호작용에 대한 설명입니다.


### 1.5 카탈로그 조직화

![[스크린샷 2025-01-12 오후 4.50.02.png]]
목적
- 생성: 객체 생성
- 구조: 객체 합성
- 행동: 상호작용과 박법이나 책임의 분산

범위
- 클래스에 적용하는지
- 객체에 적용하는지

디자인패턴과의 관계
- **일부 패턴은 함께 자주 사용**
    - 예: Composite는 Iterator나 Visitor와 자주 함께 사용됨.
- **일부 패턴은 대안으로 사용**
    - 예: Prototype은 Abstract Factory의 대안으로 자주 사용됨.
-  **일부 패턴은 의도는 다르지만 유사한 설계를 제공**
    - 예: Composite와 Decorator의 구조 다이어그램은 유사함.

![[스크린샷 2025-01-12 오후 5.05.37.png]]
### 1.6 디자인패턴을 이용하여 문제를 푸는 방법
내부 목차는 이렇게 되어있다.
- 적당한 객체를 만들기
- 객체의 크기 결정
- 객체 인터페이스의 명세
- 객체 구현 명세하기
- 재사용을 실현 가능한 것으로
- 런타임 및 컴파일 타임의 구조를 관계짓기
- 변화에 대비한 설계

##### 적당한 객체를 만들기
An object packages both data and the procedures that operate on that data.
- 객체는 데이터와 이를 처리하는 절차(메서드)**를 패키징함.
- 캡슐화(encapsulated) 에 대한 이야기들을 풀어나감

객체지향 설계의 어려움: 시스템을 객체로 반영
- 객체지향 설계에서 가장 어려운 점은 시스템을 적절히 객체로 분해하는 것임.
- 분해 과정에서 영향을 미치는 주요 요소들
    - 캡슐화, 세분성, 의존성, 유연성, 성능, 진화, 재사용성 등.
    - 이 요소들은 서로 충돌할 수 있어 설계를 복잡하게 만듦.

현실과 객체지향 설계 간의 간극이 있음
• 객체지향 설계에서 생성된 클래스 중 일부는 현실 세계에 대응되는 개념이 없음.
• 예: 배열(Array) 같은 저수준 클래스.
• 일부 클래스는 더 높은 추상화 수준에 있음.
• 현실 세계를 엄격히 모델링하면 현재를 반영할 수 있지만, 미래의 요구사항에는 적합하지 않을 수 있음.

##### 객체 인터페이스 명세
- 모든 operation 은 signature 에 의해 정의되어 있음
    - 인터페이스: signature 의 집합
- **Dynamic Binding**: 런타임 시에 동일한 인터페이스를 가진 서로 다른 구현의 객체를 대체(substitute) 가능하게 하며, 이를 통해 다형성(polymorphism)을 제공.
    - **Polymorphism**: 클라이언트 객체가 특정 인터페이스를 지원하는 객체와만 상호작용하도록 하여 객체 간 결합을 줄이고, 런타임 관계를 유연하게 만듦.
- 디자인패턴은 인터페이스의 핵심 요소와 데이터 종류를 정의하는 데 도움을 줌
    - 인터페이스에 어떤 요소를 포함하고 포함하지 말아야 할지에 대한 가이드를 제공함.


##### 객체 구현 명세하기

Class 와 Type 을 구분하는 것을 강조함

**Class**:
- 객체의 구현 방식을 정의.
- 객체의 내부 상태와 동작의 구현을 결정.

**Type**:
- 객체가 응답할 수 있는 인터페이스를 지칭
- 구현 세부사항과는 무관하며, 객체가 지원하는 기능을 의미.

**클래스, 타입, 객체 (Polymorphism)**:
- 하나의 객체는 여러 개의 타입을 가질 수 있음.
- 서로 다른 클래스의 객체도 동일한 타입을 가질 수 있음.


**클래스 상속 VS 인터페이스 상속**
> Programming to an Interface, not an Implementation
- 구체적인 클래스 인스턴스가 아닌 **추상 클래스나 인터페이스**에만 의존하도록 설계.
- 인터페이스를 기반으로 프로그래밍함으로써 서브시스템 간 **구현 의존성**을 줄이고, **유연성과 재사용성**을 향상.


클래스: 객체가 어떻게 구현 되는가를 정의
- 클래스 상속: 이미 정의된 객체의 구현을 상속함
  인터페이스: 객체의 타입. 그 객체가 처리할 수 있는/ 요청의 집합.
- 인터페이스 상속: 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정


**클래스 상속의 목적:**
- **구현 재사용**: 기존 클래스를 상속받아 새로운 기능을 손쉽게 추가.
- **동일한 인터페이스 제공**: 추상 클래스나 인터페이스를 통해 object family 정의하고 다형성을 활용.



**구현체가 아닌 추상 클래스를 기반으로 객체를 다룰 때의 두 가지 장점**:
- 클라이언트는 객체의 **구체적인 타입**을 몰라도 됨.
- 클라이언트는 **객체를 구현한 클래스**에 대해 몰라도 됨.


##### 재사용을 실현 가능한 것으로

기능의 재사용을 위해 사용하는 방법 두가지에 대해서 살펴봅시다

**클래스 상속**
- white-box reuse: 부모클래스의 내부가 서브클래스에 공개됨
    - super() 뿐만 아니라 부모의 구현을 알고 호출할 수 있음
- 런타임에 변경 불가능
- 일부만 상속하거나 재정의 -> 캡슐화가 깨짐
- 부모 클래스 구현에 변경이 생기면, 서브클래스도 전부 변경해야 함 -> SRP 위반

**객체 합성**
- 반대로 black-box reuse: 인터페이스만 알고 사용함

**위임**
- 항상 합성과 헷갈림. 추상적인 느낌으로 보면 위임은 행위의 주도자가 넘어가는 듯.
    - 합성: 자동차와 엔진: has-a
        - composition 은 **단순히 객체가 다른 객체를 포함하여 협력하는 넓은 개념**
    - 위임: 직원과 프린터기: do-it-for-me
        - delegation은 **특정 작업(책임)을 명시적으로 다른 객체에게 완전하게 넘기는 경우**
        - 합성의 극단적 예라고 볼 수도 있겠음
- 런타임에 행동을 교체 가능함.
    - 즉 행동이 교체 가능하려면 매개변수화가 되는데, 정적인 구조보다 복잡도가 늘어남
    - 위임이 만드는 복잡도보다 위임으로 인한 단순화가 더 훌륭하다면 좋은 설계


##### 런타임 및 컴파일 타임의 구조를 관계짓기

**Aggregation(집합)**: 한 객체가 다른 객체를 소유하거나 책임진다는 의미.
- 객체의 소유 또는 일부분이라는 개념이며, 집합 객체와 소유 객체는 동일한 생명주기를 가짐.
- DDD 의 Aggregate
- 관계가 비교적 적고 영구적임

**Acquaintance(연관)**: 한 객체가 단순히 다른 객체를 **알고 있는** 관계.
- 집합보다는 약한 결합도를 가지며, 주로 **association** 또는 **using 관계**로 불림.
- 관계가 더 자주 생성되고 소멸됨

##### 변화에 대비한 설계
1. 명시적으로 클래스 지정하여 객체 생성
    1. 특정 구현에 의존하므로 변경이 어렵다.
2. 특정 작업에 대한 의존성
    1. 요청 처리 방식을 고정하면 변경이 어려움.
3. 하드웨어 및 소프트웨어 플랫폼 의존성
    1. 플랫폼 종속성은 이식성과 업데이트를 어렵게 함.
4. 객체 표현 또는 구현에 대한 의존성
    1. 객체 표현이 변경되면 클라이언트 코드도 변경 필요.
5. 알고리즘 의존성
    1. 알고리즘 변경 시 영향을 받는 객체의 변경 필요.
6. 강한 결합(Tight Coupling)
    1. 클래스 간 강한 결합은 재사용과 변경을 어렵게 만듦.
7. 서브클래싱으로 기능 확장
    1. 서브클래싱은 복잡성을 증가시키며 과도한 서브클래스 생성 위험.
8. 클래스 수정의 어려움
    1. 상용 클래스 라이브러리를 수정해야 할 경우 번거로움.

### 1.7 디자인 패턴을 고르는 방법
1.
2. 디자인 패턴이 문제를 해결하는 방식 검토
    1. 패턴이 객체를 적절히 찾고, 인터페이스를 지정하며, 설계를 단순화하는 방법을 이해하여 적합한 패턴을 선택.
3. 의도(Intents) 섹션 탐색
    1. 각 패턴의 의도를 검토하고 문제와 관련된 의도를 가진 패턴을 좁혀 선택.
4. 패턴 간 상호작용 연구
    1. 패턴들 간의 관계를 그래프로 살펴보고 문제에 적합한 패턴 그룹 또는 패턴을 선택.
5. 유사한 목적의 패턴 비교
    1. 생성, 구조, 행동 패턴 간 차이점과 공통점을 분석하여 선택.
6. 재설계 원인 분석
    1. 재설계가 필요한 원인을 분석하고, 이를 해결할 수 있는 패턴을 찾음.
7. 설계에서 변해야 할 요소 고려
    1. 변경이 예상되는 설계 요소를 미리 추출하고, 캡슐화할 수 있는 패턴을 선택.